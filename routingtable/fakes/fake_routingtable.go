// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"sync"

	"github.com/F5Networks/cf-bigip-ctlr/routingtable"
)

type FakeRouteTable struct {
	UpsertBackendServerKeyStub        func(key routingtable.RoutingKey, info routingtable.BackendServerInfo) bool
	upsertBackendServerKeyMutex       sync.RWMutex
	upsertBackendServerKeyArgsForCall []struct {
		key  routingtable.RoutingKey
		info routingtable.BackendServerInfo
	}
	upsertBackendServerKeyReturns struct {
		result1 bool
	}
	upsertBackendServerKeyReturnsOnCall map[int]struct {
		result1 bool
	}
	DeleteBackendServerKeyStub        func(key routingtable.RoutingKey, info routingtable.BackendServerInfo) bool
	deleteBackendServerKeyMutex       sync.RWMutex
	deleteBackendServerKeyArgsForCall []struct {
		key  routingtable.RoutingKey
		info routingtable.BackendServerInfo
	}
	deleteBackendServerKeyReturns struct {
		result1 bool
	}
	deleteBackendServerKeyReturnsOnCall map[int]struct {
		result1 bool
	}
	NumberOfRoutesStub        func() int
	numberOfRoutesMutex       sync.RWMutex
	numberOfRoutesArgsForCall []struct{}
	numberOfRoutesReturns     struct {
		result1 int
	}
	numberOfRoutesReturnsOnCall map[int]struct {
		result1 int
	}
	NumberOfBackendsStub        func(key routingtable.RoutingKey) int
	numberOfBackendsMutex       sync.RWMutex
	numberOfBackendsArgsForCall []struct {
		key routingtable.RoutingKey
	}
	numberOfBackendsReturns struct {
		result1 int
	}
	numberOfBackendsReturnsOnCall map[int]struct {
		result1 int
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeRouteTable) UpsertBackendServerKey(key routingtable.RoutingKey, info routingtable.BackendServerInfo) bool {
	fake.upsertBackendServerKeyMutex.Lock()
	ret, specificReturn := fake.upsertBackendServerKeyReturnsOnCall[len(fake.upsertBackendServerKeyArgsForCall)]
	fake.upsertBackendServerKeyArgsForCall = append(fake.upsertBackendServerKeyArgsForCall, struct {
		key  routingtable.RoutingKey
		info routingtable.BackendServerInfo
	}{key, info})
	fake.recordInvocation("UpsertBackendServerKey", []interface{}{key, info})
	fake.upsertBackendServerKeyMutex.Unlock()
	if fake.UpsertBackendServerKeyStub != nil {
		return fake.UpsertBackendServerKeyStub(key, info)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.upsertBackendServerKeyReturns.result1
}

func (fake *FakeRouteTable) UpsertBackendServerKeyCallCount() int {
	fake.upsertBackendServerKeyMutex.RLock()
	defer fake.upsertBackendServerKeyMutex.RUnlock()
	return len(fake.upsertBackendServerKeyArgsForCall)
}

func (fake *FakeRouteTable) UpsertBackendServerKeyArgsForCall(i int) (routingtable.RoutingKey, routingtable.BackendServerInfo) {
	fake.upsertBackendServerKeyMutex.RLock()
	defer fake.upsertBackendServerKeyMutex.RUnlock()
	return fake.upsertBackendServerKeyArgsForCall[i].key, fake.upsertBackendServerKeyArgsForCall[i].info
}

func (fake *FakeRouteTable) UpsertBackendServerKeyReturns(result1 bool) {
	fake.UpsertBackendServerKeyStub = nil
	fake.upsertBackendServerKeyReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeRouteTable) UpsertBackendServerKeyReturnsOnCall(i int, result1 bool) {
	fake.UpsertBackendServerKeyStub = nil
	if fake.upsertBackendServerKeyReturnsOnCall == nil {
		fake.upsertBackendServerKeyReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.upsertBackendServerKeyReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeRouteTable) DeleteBackendServerKey(key routingtable.RoutingKey, info routingtable.BackendServerInfo) bool {
	fake.deleteBackendServerKeyMutex.Lock()
	ret, specificReturn := fake.deleteBackendServerKeyReturnsOnCall[len(fake.deleteBackendServerKeyArgsForCall)]
	fake.deleteBackendServerKeyArgsForCall = append(fake.deleteBackendServerKeyArgsForCall, struct {
		key  routingtable.RoutingKey
		info routingtable.BackendServerInfo
	}{key, info})
	fake.recordInvocation("DeleteBackendServerKey", []interface{}{key, info})
	fake.deleteBackendServerKeyMutex.Unlock()
	if fake.DeleteBackendServerKeyStub != nil {
		return fake.DeleteBackendServerKeyStub(key, info)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.deleteBackendServerKeyReturns.result1
}

func (fake *FakeRouteTable) DeleteBackendServerKeyCallCount() int {
	fake.deleteBackendServerKeyMutex.RLock()
	defer fake.deleteBackendServerKeyMutex.RUnlock()
	return len(fake.deleteBackendServerKeyArgsForCall)
}

func (fake *FakeRouteTable) DeleteBackendServerKeyArgsForCall(i int) (routingtable.RoutingKey, routingtable.BackendServerInfo) {
	fake.deleteBackendServerKeyMutex.RLock()
	defer fake.deleteBackendServerKeyMutex.RUnlock()
	return fake.deleteBackendServerKeyArgsForCall[i].key, fake.deleteBackendServerKeyArgsForCall[i].info
}

func (fake *FakeRouteTable) DeleteBackendServerKeyReturns(result1 bool) {
	fake.DeleteBackendServerKeyStub = nil
	fake.deleteBackendServerKeyReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeRouteTable) DeleteBackendServerKeyReturnsOnCall(i int, result1 bool) {
	fake.DeleteBackendServerKeyStub = nil
	if fake.deleteBackendServerKeyReturnsOnCall == nil {
		fake.deleteBackendServerKeyReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.deleteBackendServerKeyReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeRouteTable) NumberOfRoutes() int {
	fake.numberOfRoutesMutex.Lock()
	ret, specificReturn := fake.numberOfRoutesReturnsOnCall[len(fake.numberOfRoutesArgsForCall)]
	fake.numberOfRoutesArgsForCall = append(fake.numberOfRoutesArgsForCall, struct{}{})
	fake.recordInvocation("NumberOfRoutes", []interface{}{})
	fake.numberOfRoutesMutex.Unlock()
	if fake.NumberOfRoutesStub != nil {
		return fake.NumberOfRoutesStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.numberOfRoutesReturns.result1
}

func (fake *FakeRouteTable) NumberOfRoutesCallCount() int {
	fake.numberOfRoutesMutex.RLock()
	defer fake.numberOfRoutesMutex.RUnlock()
	return len(fake.numberOfRoutesArgsForCall)
}

func (fake *FakeRouteTable) NumberOfRoutesReturns(result1 int) {
	fake.NumberOfRoutesStub = nil
	fake.numberOfRoutesReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeRouteTable) NumberOfRoutesReturnsOnCall(i int, result1 int) {
	fake.NumberOfRoutesStub = nil
	if fake.numberOfRoutesReturnsOnCall == nil {
		fake.numberOfRoutesReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.numberOfRoutesReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeRouteTable) NumberOfBackends(key routingtable.RoutingKey) int {
	fake.numberOfBackendsMutex.Lock()
	ret, specificReturn := fake.numberOfBackendsReturnsOnCall[len(fake.numberOfBackendsArgsForCall)]
	fake.numberOfBackendsArgsForCall = append(fake.numberOfBackendsArgsForCall, struct {
		key routingtable.RoutingKey
	}{key})
	fake.recordInvocation("NumberOfBackends", []interface{}{key})
	fake.numberOfBackendsMutex.Unlock()
	if fake.NumberOfBackendsStub != nil {
		return fake.NumberOfBackendsStub(key)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.numberOfBackendsReturns.result1
}

func (fake *FakeRouteTable) NumberOfBackendsCallCount() int {
	fake.numberOfBackendsMutex.RLock()
	defer fake.numberOfBackendsMutex.RUnlock()
	return len(fake.numberOfBackendsArgsForCall)
}

func (fake *FakeRouteTable) NumberOfBackendsArgsForCall(i int) routingtable.RoutingKey {
	fake.numberOfBackendsMutex.RLock()
	defer fake.numberOfBackendsMutex.RUnlock()
	return fake.numberOfBackendsArgsForCall[i].key
}

func (fake *FakeRouteTable) NumberOfBackendsReturns(result1 int) {
	fake.NumberOfBackendsStub = nil
	fake.numberOfBackendsReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeRouteTable) NumberOfBackendsReturnsOnCall(i int, result1 int) {
	fake.NumberOfBackendsStub = nil
	if fake.numberOfBackendsReturnsOnCall == nil {
		fake.numberOfBackendsReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.numberOfBackendsReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeRouteTable) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.upsertBackendServerKeyMutex.RLock()
	defer fake.upsertBackendServerKeyMutex.RUnlock()
	fake.deleteBackendServerKeyMutex.RLock()
	defer fake.deleteBackendServerKeyMutex.RUnlock()
	fake.numberOfRoutesMutex.RLock()
	defer fake.numberOfRoutesMutex.RUnlock()
	fake.numberOfBackendsMutex.RLock()
	defer fake.numberOfBackendsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeRouteTable) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ routingtable.RouteTable = new(FakeRouteTable)
