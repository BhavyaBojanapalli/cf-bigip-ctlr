// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"sync"
	"time"

	"github.com/F5Networks/cf-bigip-ctlr/routingtable"
)

type FakeRouteTable struct {
	PruneEntriesStub        func(defaultTTL time.Duration)
	pruneEntriesMutex       sync.RWMutex
	pruneEntriesArgsForCall []struct {
		defaultTTL time.Duration
	}
	UpsertBackendServerKeyStub        func(key routingtable.RoutingKey, info routingtable.BackendServerInfo) bool
	upsertBackendServerKeyMutex       sync.RWMutex
	upsertBackendServerKeyArgsForCall []struct {
		key  routingtable.RoutingKey
		info routingtable.BackendServerInfo
	}
	upsertBackendServerKeyReturns struct {
		result1 bool
	}
	upsertBackendServerKeyReturnsOnCall map[int]struct {
		result1 bool
	}
	DeleteBackendServerKeyStub        func(key routingtable.RoutingKey, info routingtable.BackendServerInfo) bool
	deleteBackendServerKeyMutex       sync.RWMutex
	deleteBackendServerKeyArgsForCall []struct {
		key  routingtable.RoutingKey
		info routingtable.BackendServerInfo
	}
	deleteBackendServerKeyReturns struct {
		result1 bool
	}
	deleteBackendServerKeyReturnsOnCall map[int]struct {
		result1 bool
	}
	CompareEntriesStub        func(newTable *routingtable.RoutingTable) bool
	compareEntriesMutex       sync.RWMutex
	compareEntriesArgsForCall []struct {
		newTable *routingtable.RoutingTable
	}
	compareEntriesReturns struct {
		result1 bool
	}
	compareEntriesReturnsOnCall map[int]struct {
		result1 bool
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeRouteTable) PruneEntries(defaultTTL time.Duration) {
	fake.pruneEntriesMutex.Lock()
	fake.pruneEntriesArgsForCall = append(fake.pruneEntriesArgsForCall, struct {
		defaultTTL time.Duration
	}{defaultTTL})
	fake.recordInvocation("PruneEntries", []interface{}{defaultTTL})
	fake.pruneEntriesMutex.Unlock()
	if fake.PruneEntriesStub != nil {
		fake.PruneEntriesStub(defaultTTL)
	}
}

func (fake *FakeRouteTable) PruneEntriesCallCount() int {
	fake.pruneEntriesMutex.RLock()
	defer fake.pruneEntriesMutex.RUnlock()
	return len(fake.pruneEntriesArgsForCall)
}

func (fake *FakeRouteTable) PruneEntriesArgsForCall(i int) time.Duration {
	fake.pruneEntriesMutex.RLock()
	defer fake.pruneEntriesMutex.RUnlock()
	return fake.pruneEntriesArgsForCall[i].defaultTTL
}

func (fake *FakeRouteTable) UpsertBackendServerKey(key routingtable.RoutingKey, info routingtable.BackendServerInfo) bool {
	fake.upsertBackendServerKeyMutex.Lock()
	ret, specificReturn := fake.upsertBackendServerKeyReturnsOnCall[len(fake.upsertBackendServerKeyArgsForCall)]
	fake.upsertBackendServerKeyArgsForCall = append(fake.upsertBackendServerKeyArgsForCall, struct {
		key  routingtable.RoutingKey
		info routingtable.BackendServerInfo
	}{key, info})
	fake.recordInvocation("UpsertBackendServerKey", []interface{}{key, info})
	fake.upsertBackendServerKeyMutex.Unlock()
	if fake.UpsertBackendServerKeyStub != nil {
		return fake.UpsertBackendServerKeyStub(key, info)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.upsertBackendServerKeyReturns.result1
}

func (fake *FakeRouteTable) UpsertBackendServerKeyCallCount() int {
	fake.upsertBackendServerKeyMutex.RLock()
	defer fake.upsertBackendServerKeyMutex.RUnlock()
	return len(fake.upsertBackendServerKeyArgsForCall)
}

func (fake *FakeRouteTable) UpsertBackendServerKeyArgsForCall(i int) (routingtable.RoutingKey, routingtable.BackendServerInfo) {
	fake.upsertBackendServerKeyMutex.RLock()
	defer fake.upsertBackendServerKeyMutex.RUnlock()
	return fake.upsertBackendServerKeyArgsForCall[i].key, fake.upsertBackendServerKeyArgsForCall[i].info
}

func (fake *FakeRouteTable) UpsertBackendServerKeyReturns(result1 bool) {
	fake.UpsertBackendServerKeyStub = nil
	fake.upsertBackendServerKeyReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeRouteTable) UpsertBackendServerKeyReturnsOnCall(i int, result1 bool) {
	fake.UpsertBackendServerKeyStub = nil
	if fake.upsertBackendServerKeyReturnsOnCall == nil {
		fake.upsertBackendServerKeyReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.upsertBackendServerKeyReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeRouteTable) DeleteBackendServerKey(key routingtable.RoutingKey, info routingtable.BackendServerInfo) bool {
	fake.deleteBackendServerKeyMutex.Lock()
	ret, specificReturn := fake.deleteBackendServerKeyReturnsOnCall[len(fake.deleteBackendServerKeyArgsForCall)]
	fake.deleteBackendServerKeyArgsForCall = append(fake.deleteBackendServerKeyArgsForCall, struct {
		key  routingtable.RoutingKey
		info routingtable.BackendServerInfo
	}{key, info})
	fake.recordInvocation("DeleteBackendServerKey", []interface{}{key, info})
	fake.deleteBackendServerKeyMutex.Unlock()
	if fake.DeleteBackendServerKeyStub != nil {
		return fake.DeleteBackendServerKeyStub(key, info)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.deleteBackendServerKeyReturns.result1
}

func (fake *FakeRouteTable) DeleteBackendServerKeyCallCount() int {
	fake.deleteBackendServerKeyMutex.RLock()
	defer fake.deleteBackendServerKeyMutex.RUnlock()
	return len(fake.deleteBackendServerKeyArgsForCall)
}

func (fake *FakeRouteTable) DeleteBackendServerKeyArgsForCall(i int) (routingtable.RoutingKey, routingtable.BackendServerInfo) {
	fake.deleteBackendServerKeyMutex.RLock()
	defer fake.deleteBackendServerKeyMutex.RUnlock()
	return fake.deleteBackendServerKeyArgsForCall[i].key, fake.deleteBackendServerKeyArgsForCall[i].info
}

func (fake *FakeRouteTable) DeleteBackendServerKeyReturns(result1 bool) {
	fake.DeleteBackendServerKeyStub = nil
	fake.deleteBackendServerKeyReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeRouteTable) DeleteBackendServerKeyReturnsOnCall(i int, result1 bool) {
	fake.DeleteBackendServerKeyStub = nil
	if fake.deleteBackendServerKeyReturnsOnCall == nil {
		fake.deleteBackendServerKeyReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.deleteBackendServerKeyReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeRouteTable) CompareEntries(newTable *routingtable.RoutingTable) bool {
	fake.compareEntriesMutex.Lock()
	ret, specificReturn := fake.compareEntriesReturnsOnCall[len(fake.compareEntriesArgsForCall)]
	fake.compareEntriesArgsForCall = append(fake.compareEntriesArgsForCall, struct {
		newTable *routingtable.RoutingTable
	}{newTable})
	fake.recordInvocation("CompareEntries", []interface{}{newTable})
	fake.compareEntriesMutex.Unlock()
	if fake.CompareEntriesStub != nil {
		return fake.CompareEntriesStub(newTable)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.compareEntriesReturns.result1
}

func (fake *FakeRouteTable) CompareEntriesCallCount() int {
	fake.compareEntriesMutex.RLock()
	defer fake.compareEntriesMutex.RUnlock()
	return len(fake.compareEntriesArgsForCall)
}

func (fake *FakeRouteTable) CompareEntriesArgsForCall(i int) *routingtable.RoutingTable {
	fake.compareEntriesMutex.RLock()
	defer fake.compareEntriesMutex.RUnlock()
	return fake.compareEntriesArgsForCall[i].newTable
}

func (fake *FakeRouteTable) CompareEntriesReturns(result1 bool) {
	fake.CompareEntriesStub = nil
	fake.compareEntriesReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeRouteTable) CompareEntriesReturnsOnCall(i int, result1 bool) {
	fake.CompareEntriesStub = nil
	if fake.compareEntriesReturnsOnCall == nil {
		fake.compareEntriesReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.compareEntriesReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeRouteTable) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.pruneEntriesMutex.RLock()
	defer fake.pruneEntriesMutex.RUnlock()
	fake.upsertBackendServerKeyMutex.RLock()
	defer fake.upsertBackendServerKeyMutex.RUnlock()
	fake.deleteBackendServerKeyMutex.RLock()
	defer fake.deleteBackendServerKeyMutex.RUnlock()
	fake.compareEntriesMutex.RLock()
	defer fake.compareEntriesMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeRouteTable) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ routingtable.RouteTable = new(FakeRouteTable)
